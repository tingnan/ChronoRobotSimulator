// ConsoleApplication1.cpp : Defines the entry point for the console
// application.
//

// Use the namespace of Chrono
#include "stdafx.h"

int _global_save_step = 100;

namespace irr {
//********************
// EVENT RECEIVER CLASS
//********************
class MyEventReceiver : public IEventReceiver {
private:
  ChIrrApp *application;
  gui::IGUICheckBox *chbox_pauephysics;
  gui::IGUIEditBox *edbox_savestep;

public:
  MyEventReceiver(ChIrrApp *myapp) {
    application = myapp;
    gui::IGUIEnvironment *mygui = myapp->GetIGUIEnvironment();
    mygui->addStaticText(L"pause physics:", core::rect<s32>(216, 16, 296, 36),
                         false, false, 0, 101);
    chbox_pauephysics = mygui->addCheckBox(
        false, core::rect<s32>(304, 16, 324, 36), 0, 103, L"");
    mygui->addStaticText(L"set save step:", core::rect<s32>(216, 40, 296, 60),
                         false, false, 0, 105);
    edbox_savestep = mygui->addEditBox(
        L"100", core::rect<s32>(304, 40, 404, 60), true, 0, 106);
    _global_save_step = _wtoi(edbox_savestep->getText());
    application->SetPaused(chbox_pauephysics->isChecked());
  }
  ~MyEventReceiver() {};

  bool OnEvent(const SEvent &event) {
    // GUI EVENT
    if (event.EventType == EET_GUI_EVENT) {
      s32 id = event.GUIEvent.Caller->getID();

      switch (event.GUIEvent.EventType) {
      case gui::EGET_CHECKBOX_CHANGED:
        if (id == 103) {
          application->SetPaused(chbox_pauephysics->isChecked());
        }
        break;
      case gui::EGET_EDITBOX_ENTER:
        if (id == 106) {
          _global_save_step = _wtoi(edbox_savestep->getText());
        }
      }
    }
    return false;
  }
};
}

using namespace chrono;
using namespace irr;
using namespace core;
using namespace scene;
using namespace video;
using namespace io;
using namespace gui;

void ReadCSV(std::ifstream &inputfile,
             std::vector<std::vector<double> > &data) {
  std::string str;
  int i = 0;
  while (std::getline(inputfile, str, '\n')) {
    std::istringstream myline(str);
    std::string mynum;
    int j = 0;
    while (std::getline(myline, mynum, ',')) {
      data[i][j] = strtod(mynum.c_str(), NULL);
      ++j;
    }
    // std::cout << data[i][0] << std::endl;
    ++i;
  }
}

// dump pos vel acc, rot, ome, and rot_acc for the body
std::ofstream nodinfofile("biped.mov");
void DumpNodInfo(ChSystem &msys) {
  nodinfofile << std::setprecision(8);
  nodinfofile << std::scientific;
  const int nnodes = msys.Get_bodylist()->size();
  for (unsigned int i = 0; i < nnodes; ++i) {
    ChBody *curbody = (*msys.Get_bodylist())[i];
    nodinfofile << curbody->GetPos() << " " << curbody->GetPos_dt() << " ";
    nodinfofile << curbody->GetRot() << " " << curbody->GetRot_dt() << "\n";
  }
}

// dump pos vel acc, rot, ome, and rot_acc for the link
std::ofstream jntinfofile("biped.jnt");
void DumpJntInfo(ChSystem &msys) {
  jntinfofile << std::setprecision(8);
  jntinfofile << std::scientific;
  std::list<ChLink *>::iterator itr;
  for (itr = msys.Get_linklist()->begin(); itr != msys.Get_linklist()->end();
       ++itr) {
    ChVector<> localforce = (*itr)->Get_react_force();
    double localtorque =
        ((chrono::ChLinkEngineControl *)*itr)->Get_mot_torque();
    jntinfofile << localforce << " " << localtorque << "\n";
    // jntinfofile << (*itr)->GetLinkRelativeCoords().rot.Rotate(localforce) <<
    // " " << (*itr)->GetLinkRelativeCoords().rot.Rotate(localtorque) << "\n";
  }
  jntinfofile.flush();
}

std::ofstream cotinfofile("biped.cot");
void DumpContact(ChSystem &msys) {
  nodinfofile << std::setprecision(8);
  nodinfofile << std::scientific;
  const int nnodes = msys.Get_bodylist()->size();
  std::map<ChBody *, ChVector<> > forcemap;
  std::map<ChBody *, ChVector<> > torquemap;
  ChContactContainer *syscot =
      (ChContactContainer *)(msys.GetContactContainer());
  std::list<ChContact *> contactlist = syscot->GetContactList();
  std::list<ChContact *>::const_iterator itr = contactlist.begin();
  for (; itr != contactlist.end(); ++itr) {
    collision::ChModelBulletBody *modelA =
        (collision::ChModelBulletBody *)((*itr)->GetModelA());
    collision::ChModelBulletBody *modelB =
        (collision::ChModelBulletBody *)((*itr)->GetModelB());
    ChBody *bodyA = modelA->GetBody();
    ChBody *bodyB = modelB->GetBody();
    ChVector<> curforce = (*itr)->GetContactForce();
    forcemap[bodyA] += curforce;
    forcemap[bodyB] -= curforce;
    ChVector<> pointA = (*itr)->GetContactP1();
    ChVector<> pointB = (*itr)->GetContactP2();
    // torque in global frame;
    torquemap[bodyA] += (pointA - bodyA->GetPos()) % curforce;
    torquemap[bodyB] -= (pointB - bodyB->GetPos()) % curforce;
  }
  for (unsigned int i = 0; i < nnodes; ++i) {
    ChBody *curbody = (*msys.Get_bodylist())[i];
  }
}

std::ofstream rftinfofile("biped.rft");
void DumpRFTForce(std::vector<RFTBody> &bodylist) {
  const int nnodes = bodylist.size();
  for (int i = 0; i < nnodes; ++i) {
    rftinfofile << bodylist[i].flist_ << "\n";
  }
}

void CreateRobot(ChIrrApp &myapp) {
  ChSystem &msys = *(myapp.GetSystem());
  std::ifstream inputfile("input.txt");
  if (!inputfile.is_open()) {
    std::cout << "No input file found. Press Enter to exit.\n";
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    exit(0);
  }
  std::vector<std::vector<double> > data(80002, std::vector<double>(9));
  ReadCSV(inputfile, data);
  ChBroadPhaseCallbackNew *mcallback = new ChBroadPhaseCallbackNew;
  msys.GetCollisionSystem()->SetBroadPhaseCallback(mcallback);
  const double lfact = 1e2;
  const double rhofact = 1e3;
  ChSharedPtr<ChBodyEasyBox> ground(new ChBodyEasyBox(
      2000 / lfact, 0.1 / lfact, 2000. / lfact, 1. * rhofact, false));
  const double bodyheight = 8. / lfact; // 28
  ChSharedPtr<ChColorAsset> mcolor(new ChColorAsset);
  mcolor->SetColor(ChColor(0.2f, 0.8f, 0.2f));
  ground->SetPos(ChVector<>(0, 0, 0.));
  ground->AddAsset(mcolor);
  ground->SetBodyFixed(true);
  ground->SetId(-1);
  ground->SetIdentifier(-1);
  msys.AddBody(ground);

  // create a torque controlled robot
  {
    ChSharedPtr<ChBodyEasyBox> upperframe(
        new ChBodyEasyBox(2. / lfact, 2. / lfact, 15. / lfact, 8. * rhofact,
                          true)); // Changed form 7 to 8
    msys.AddBody(upperframe);
    upperframe->SetPos(ChVector<>(0, bodyheight, 0.));
    upperframe->SetId(0);
    upperframe->SetBodyFixed(true);
    /*ChSharedPtr<ChLinkLockOldham> inplanelink(new ChLinkLockOldham);
    inplanelink->Initialize(ground, upperframe, ChCoordsys<>(ChVector<>()));
    msys.AddLink(inplanelink);
*/
    const double leglen[4] = { 7.57 / lfact, 7.77 / lfact,
                               7.48 / lfact, 3.40 / lfact };
    const ChQuaternion<> qter = Q_from_AngZ(-CH_C_PI_2);
    std::vector<ChSharedPtr<ChBodyEasyBox> > legcontainer(8);

    for (int j = 0; j < 2; ++j) {
      double z_step = -7.5 / lfact;
      if (j == 1)
        z_step = -z_step;
      double y_step = bodyheight + leglen[0] / 2.;
      for (int k = 0; k < 4; ++k) {

        double x_step = 0. / lfact;
        if (k == 0)
          y_step = y_step - leglen[k];
        else
          y_step = y_step - 0.5 * (leglen[k] + leglen[k - 1]);
        double legw = 2.0 / lfact;
        double legh = 2.0 / lfact;
        if (k == 3) {
          legw = 5.0 / lfact;
        }
        if (k == 3) {
          legcontainer[j * 4 + k] = ChSharedPtr<ChBodyEasyBox>(
              new ChBodyEasyBox(leglen[k], legw, legw, 5 * rhofact,
                                true)); // Cut mass of foot by 5
        } else {
          legcontainer[j * 4 + k] = ChSharedPtr<ChBodyEasyBox>(
              new ChBodyEasyBox(leglen[k], legw, legw, 5. * rhofact, true));
        }
        // if ((j == 1) && (k == 3))
        //{
        //	legcontainer[j * 4 + k] = ChSharedPtr<ChBodyEasyBox>(new
        //ChBodyEasyBox(leglen[k], legw, legw, 0.05 * rhofact, true));//Make
        //other foot enormous
        //}
        legcontainer[j * 4 + k]->SetRot(qter);
        legcontainer[j * 4 + k]->SetPos(ChVector<>(x_step, y_step, z_step));
        legcontainer[j * 4 + k]->SetId(k + 1);
        msys.AddBody(legcontainer[j * 4 + k]);

        ChSharedPtr<ChLinkEngineControl> mylink(new ChLinkEngineControl);

        /*	if ((j == 1) && (k == 3))
                {
                        mylink->Set_mot_torque_limits(0., -0.);
                }
                else if ((j==1) && (k == 1))
                {
                        mylink->Set_mot_torque_limits(1.,-1.);
                }
                else
                {
                mylink->Set_mot_torque_limits(3., -3.);
                }*/
        mylink->Set_mot_gain(30., 0, 0.3);
        if (k == 0)
          mylink->Initialize(legcontainer[j * 4 + k], upperframe,
                             ChCoordsys<>(ChVector<>(
                                 x_step, y_step + leglen[k] / 2.0, z_step)));
        else
          mylink->Initialize(legcontainer[j * 4 + k],
                             legcontainer[j * 4 + k - 1],
                             ChCoordsys<>(ChVector<>(
                                 x_step, y_step + leglen[k] / 2.0, z_step)));
        mylink->Set_eng_mode(ChLinkEngineControl::ENG_MODE_TORQUE);
        ChFunction_Data *funptr = new ChFunction_Data(data);
        funptr->SetColumn(j * 4 + k + 1);
        mylink->Set_rot_funct(funptr);
        msys.AddLink(mylink);
      }
    }
  }

  double zshift = 0.01;
  // create a perfactly controlled robot
  {
    ChSharedPtr<ChColorAsset> mcolor(new ChColorAsset);
    mcolor->SetColor(ChColor(0.3f, 0.3f, 0.6f));
    ChSharedPtr<ChBodyEasyBox> upperframe(new ChBodyEasyBox(
        2. / lfact, 2. / lfact, 15. / lfact, 7. * rhofact, true));
    msys.AddBody(upperframe);
    upperframe->SetPos(ChVector<>(0, bodyheight, zshift));
    upperframe->SetId(0);
    upperframe->AddAsset(mcolor);
    upperframe->SetBodyFixed(true);
    // ChSharedPtr<ChLinkLockOldham> inplanelink(new ChLinkLockOldham);
    // inplanelink->Initialize(ground, upperframe, ChCoordsys<>(ChVector<>()));
    // msys.AddLink(inplanelink);

    const double leglen[4] = { 7.57 / lfact, 7.77 / lfact,
                               7.48 / lfact, 3.40 / lfact };
    const ChQuaternion<> qter = Q_from_AngZ(-CH_C_PI_2);
    std::vector<ChSharedPtr<ChBodyEasyBox> > legcontainer(8);

    for (int j = 0; j < 2; ++j) {
      double z_step = -7.5 / lfact;
      if (j == 1)
        z_step = -z_step;
      z_step = z_step + zshift;
      double y_step = bodyheight + leglen[0] / 2.;
      // for each of the joints
      for (int k = 0; k < 4; ++k) {

        double x_step = 0. / lfact;
        if (k == 0)
          y_step = y_step - leglen[k];
        else
          y_step = y_step - 0.5 * (leglen[k] + leglen[k - 1]);
        double legw = 2.0 / lfact;
        double legh = 2.0 / lfact;
        if (k == 3) {
          legw = 5.0 / lfact;
        }
        legcontainer[j * 4 + k] = ChSharedPtr<ChBodyEasyBox>(
            new ChBodyEasyBox(leglen[k], legw, legw, 5. * rhofact, true));
        legcontainer[j * 4 + k]->SetRot(qter);
        legcontainer[j * 4 + k]->SetPos(ChVector<>(x_step, y_step, z_step));
        legcontainer[j * 4 + k]->SetId(k + 1);
        legcontainer[j * 4 + k]->AddAsset(mcolor);
        msys.AddBody(legcontainer[j * 4 + k]);

        ChSharedPtr<ChLinkEngineControl> mylink(new ChLinkEngineControl);
        mylink->Set_mot_torque_limits(3., -3.);
        mylink->Set_mot_gain(50., 0, 0.3);
        if (k == 0)
          mylink->Initialize(legcontainer[j * 4 + k], upperframe,
                             ChCoordsys<>(ChVector<>(
                                 x_step, y_step + leglen[k] / 2.0, z_step)));
        else
          mylink->Initialize(legcontainer[j * 4 + k],
                             legcontainer[j * 4 + k - 1],
                             ChCoordsys<>(ChVector<>(
                                 x_step, y_step + leglen[k] / 2.0, z_step)));
        mylink->Set_eng_mode(ChLinkEngineControl::ENG_MODE_ROTATION);
        ChFunction_Data *funptr = new ChFunction_Data(data);
        funptr->SetColumn(j * 4 + k + 1);
        mylink->Set_rot_funct(funptr);
        msys.AddLink(mylink);
      }
    }
  }
}

void apply_rft_force(std::vector<RFTBody> &bodylist, RFTSystem &rsystem) {
  const int nnodes = bodylist.size();
  for (unsigned int i = 0; i < nnodes; ++i) {
    bodylist[i].pbody_->Empty_forces_accumulators();
    rsystem.InteractExt(bodylist[i]);
  }
}

int main(int argc, char *argv[]) {

  // Create a ChronoENGINE physical system
  ChSystem my_system;
  my_system.Set_G_acc(ChVector<>(0, -9.81, 0));
  my_system.SetIterLCPmaxItersSpeed(100);
  my_system.SetIterLCPmaxItersStab(100);
  my_system.SetLcpSolverType(ChSystem::eCh_lcpSolver::LCP_ITERATIVE_PMINRES);
  my_system.SetTol(1e-8);
  my_system.SetTolSpeeds(1e-8);
  RFTSystem rsystem(4000, 1000);
  rsystem.InitializeMatrix("ga.bin", "al.bin", "fp.bin", "fd.bin");

  // Create the Irrlicht visualization (open the Irrlicht device,
  // bind a simple user interface, etc. etc.)
  ChIrrApp application(&my_system, L"A simple RFT example",
                       core::dimension2d<u32>(800, 600), false, true,
                       video::EDT_OPENGL);
  // Easy shortcuts to add logo, camera, lights and sky in Irrlicht scene:
  ChIrrWizard::add_typical_Logo(application.GetDevice());
  ChIrrWizard::add_typical_Sky(application.GetDevice());
  ChIrrWizard::add_typical_Lights(application.GetDevice());
  ChIrrWizard::add_typical_Camera(application.GetDevice(),
                                  core::vector3df(0, 0.0, 0.5));
  // This is for GUI tweaking of system parameters..
  MyEventReceiver receiver(&application);
  // note how to add the custom event receiver to the default interface:
  application.SetUserEventReceiver(&receiver);

  CreateRobot(application);
  application.AssetBindAll();
  application.AssetUpdateAll();

  // now we have RFTBody
  const int nnodes = my_system.Get_bodylist()->size();
  std::vector<RFTBody> bodylist;
  for (unsigned int i = 0; i < nnodes; ++i) {
    if ((*my_system.Get_bodylist())[i]->GetId() == 4) {
      std::cout << "pushed\n";
      bodylist.emplace_back();
      bodylist.back().pbody_ = (*my_system.Get_bodylist())[i];
    }
  }

  // begin
  application.SetStepManage(true);
  application.SetTimestep(1e-4);
  application.SetTryRealtime(false);
  int count = 0;
  while (application.GetDevice()->run()) {
    application.GetVideoDriver()->beginScene(true, true,
                                             video::SColor(255, 140, 161, 192));
    application.DrawAll();
    ChIrrTools::drawGrid(
        application.GetVideoDriver(), 2, 2, 20, 20,
        ChCoordsys<>(ChVector<>(0, 0, 0), Q_from_AngX(CH_C_PI_2)),
        video::SColor(255, 80, 100, 100), true);
    apply_rft_force(bodylist, rsystem);
    application.DoStep();
    application.GetVideoDriver()->endScene();
    if (count >= _global_save_step - 1) {
      std::cout << std::fixed << std::setprecision(4) << my_system.GetChTime()
                << std::endl;
      DumpNodInfo(my_system);
      DumpJntInfo(my_system);
      DumpRFTForce(bodylist);
      count = 0;
    }
    if (my_system.GetChTime() > 7) {
      break; // std::terminate();
    }
    if (!application.GetPaused())
      ++count;

    // application.SetVideoframeSave(true);
    // application.SetVideoframeSaveInterval(3333);
  }

  return 0;
}
